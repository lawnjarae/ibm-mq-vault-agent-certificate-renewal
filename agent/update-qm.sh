#!/bin/bash
set -e

# IMPORTANT! VAULT_ADDR should be set as an environment variable

# Use the token generated by Vault Agent. This means this script will have the same policies as the Vault Agent.
export VAULT_TOKEN="$(cat /opt/vault/vault-agent/token-dir/vault-token-via-agent)"

# Get the KDB password from Vault
KDB_PASSWORD=$(vault kv get -namespace=admin/ibm_mq_clm -mount="secret" -field="kdb_password" "qmgrs/QM1")

# --- Configuration ---
# The name of the single queue manager you want to process.
QMGR_NAME="QM1"
CERT_BASE_DIR="/var/mqm/qmgrs"
# Temporary file for the MQSC command
MQSC_SCRIPT="/tmp/mqsc_update_qm_${QMGR_NAME}.mqsc"

echo "--- Starting certificate refresh for single QM: ${QMGR_NAME} ---"

# Set up variables for the target queue manager
QMGR_DIR="${CERT_BASE_DIR}/${QMGR_NAME}/ssl/"
QMGR_NAME_LOWER=$(echo "${QMGR_NAME}" | tr '[:upper:]' '[:lower:]')

# Verify the certificate directory exists before proceeding
if [ ! -d "${QMGR_DIR}" ]; then
    echo "Error: Directory for queue manager ${QMGR_NAME} not found at ${QMGR_DIR}"
    exit 1
fi

# Define file paths
KEY_FILE="${QMGR_DIR}privatekey.key"
CERT_FILE="${QMGR_DIR}cert.pem"
CHAIN_FILE="${QMGR_DIR}chain.pem"
TIMESTAMP=$(date +%Y%m%d%H%M%S)
BASE_KDB_FILE_NAME="key${TIMESTAMP}"
KDB_FILE="${QMGR_DIR}${BASE_KDB_FILE_NAME}.kdb"
KDB_FILE_NO_EXT="${QMGR_DIR}${BASE_KDB_FILE_NAME}"
TEMP_P12_FILE="${QMGR_DIR}temp.p12"

# Define the label for this certificate
CERT_LABEL="ibmwebspheremq${QMGR_NAME_LOWER}"

# Create the KDB and stash file if they don't exist
if [ ! -f "${KDB_FILE}" ]; then
    echo "KDB file not found. Creating new keystore and stash file..."
    runmqakm -keydb -create -db "${KDB_FILE}" -pw "${KDB_PASSWORD}" -type cms -stash
fi

# Add the issuer (CA chain) certificates to the KDB.
echo "Adding CA chain certificates to KDB..."
runmqakm -cert -add -db "${KDB_FILE}" -pw "${KDB_PASSWORD}" -type cms -label "CARoot" -file "${CHAIN_FILE}" -trust enable || echo "CA already exists. Continuing..."

# Combine the new key and cert into a temporary PKCS#12 file.
echo "Creating temporary PKCS#12 file..."
openssl pkcs12 -export -out "${TEMP_P12_FILE}" \
  -inkey "${KEY_FILE}" -in "${CERT_FILE}" \
  -certfile "${CHAIN_FILE}" \
  -passout pass:"${KDB_PASSWORD}" -name "${CERT_LABEL}"

# Import the PKCS#12 file into the KDB
echo "Importing new personal certificate into KDB..."
runmqakm -cert -import -file "${TEMP_P12_FILE}" -type pkcs12 -pw "${KDB_PASSWORD}" \
  -target "${KDB_FILE}" -target_pw "${KDB_PASSWORD}" -target_type cms

# Clean up the temporary PKCS#12 file
rm -f "${TEMP_P12_FILE}"

# Schedule the QM security refresh
echo "Sending REFRESH SECURITY command to ${QMGR_NAME}..."
cat > "${MQSC_SCRIPT}" <<EOF
ALTER QMGR SSLKEYR('${KDB_FILE_NO_EXT}')
ALTER QMGR CERTLABL('${CERT_LABEL}')
REFRESH SECURITY TYPE(SSL)
EOF

if [ $? -ne 0 ]; then
  echo "ERROR: Failed to create MQSC script file: ${MQSC_SCRIPT}"
  exit 1
fi

# Schedule the REFRESH SECURITY command with 'at'
# This command will run only once, on the next Sunday at 2:00 AM local time.
echo "/opt/mqm/bin/runmqsc ${QMGR_NAME} < ${MQSC_SCRIPT} 2>&1" | /usr/bin/at "2:00 AM Sunday"

if [ $? -eq 0 ]; then
  echo "Successfully scheduled MQ REFRESH SECURITY for ${QMGR_NAME} at 2:00 AM Sunday"
else
  echo "ERROR scheduling MQ REFRESH SECURITY with 'at'. Check 'atd' status and permissions"
  exit 1
fi

# Clean up old KDB files, keeping only the 2 most recent sets
ls ${CERT_BASE_DIR}/${QMGR_NAME}/ssl/key*.??? | sort -r | tail -n +9 | xargs rm